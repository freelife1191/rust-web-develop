
# 🚦 1. 왜 러스트 인가?

## 1.1 배터리 포함: 러스트 도구

---

러스트 설치하기

```shell
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

러스트 업데이트

```shell
$ rustup update
```

러스트 코드 포메터 `Rustfmt` 설치하기

```shell
$ rustup component add rustfmt
```

첫 번째 러스트 프로그램 실행하기

```shell
$ cargo new hello
$ cd hello
$ cargo run
```

클리피 설치하기

```shell
$ rustup component add clippy
```

## 1.2 러스트 컴파일러

---

러스트는 코드를 실행할 때 호출되는 가비지 컬렉션이 없는 바이너리 코드로 컴파일한다    
C와 같은 속도를 내지만, C와는 달리 컴파일할 때 메모리 안정성을 강제한다

## 1.3 웹 서비스를 위한 러스트

---

웹 프레임워크를 사용할 때 이런 라이브러리는 프레임워크별로 이미 정해져 있다  
예를 들어 **ActixWeb** 웹 프레임워크는 자체 HTTP 서버 구현인 `actix-server`를 사용한다  
`Wrap`, `Axum`, `Rocket`은 (소켓 열기, 대기 및 HTTP 메시지 파싱 용도로) 모두 Hyper를 웹 서버로 사용한다


러스트로 작성한 TCP 서버 예제

```rust
use std::net::{TcpListener, TcpStream};

fn handle_client(mut stream: TcpStream) {
    // 여기서 실제적인 일을 한다
}

fn main() -> std::io::Resunt<()> {
	let listener = TcpListener::bind("127.0.0.1:80")?;
    
	for stream in listener.incoming() { 
        handle_client(stream?); 
	}
    OK(())
}
```

HTTP Get 요청을 러스트에서 비동기적으로 보내기

- 구문: async/await
- 타입: Future
- 런타임: Tokio, async-std
- 비동기 커널 추상화: Mio
- 리눅스, 다윈, 윈도우 10.0, ...

main 함수에 `#[tokio::main]` 주석을 단다  
Tokio는 여기서 사용하는 비동기 런타임(또는 스레드 스케줄러)이다  
Tokio 자체는 비동기 커널 API를 (Mio라는 크레이트를 통해) 이용한다  

표준 러스트 구문을 사용해 함수를 async로 표시하고 퓨처 타입 결과를 기다릴(await) 수 있다  
러스트의 퓨처는 트레이트로, 다른 어떤 타입으로도 구현될 수 있다  
이 트레이트는 구현 대상이 Output(계산이 완료될 때 퓨처가 반환하는 것을 나타냄) 타입과 poll 함수(런타임이 퓨처에 작업을 수행하기 위해 호출할 수 있음)를 가져오는 것을 나타낸다  

다른 언어와 달리 러스트에서는 퓨처에 의한 작업이 런타임으로 전달된 후 능동적으로 수행될 때만 시작된다
비동기 함수는 Future 타입을 반환하고, 해당 함수의 호출자는 반환된 퓨처를 런타임 작업에 전달해 작업을 진행시킨다

## 1.4 러스트 애플리케이션의 유지보수성

---

- 러스트 컴파일러가 견고한 소프트웨어를 작성하는 데 도움이 됨
- 다른 언어 기능은 러스트를 유용하게 유지보수하는 데 도움을 준다
  - 문서화 기능이 언어 자체에 내장되어 있다
  - 패키지 관리자인 카고에는 코드 주석으로 문서를 생성하는 명령이 있다
  - 이 문서는 로컬에서 볼 수 있다
  - 라이브러리를 create.io로 내보낼 때 기본적으로 만들어진다
  - 코드 문서에 포함된 코드는 미리 HTML 문서에 표시될 뿐만 아니라 테스트로 실행할 수 있으므로 예제가 구식이 될 일이 없다
- 각 부분을 함께 그룹화하거나 재사용할 수 있는 코드를 자체 크레이트로 추출할 때 도움을 주는 코드베이스 모듈화
  - 러스트는 cargo.toml의 dependencies 섹션을 이용해서 공식 crate.io 저장소나 원하는 다른 위치에 있는 로컬 라이브러리를 쉽게 가져올 수 있다
- 러스트는 테스트도 기본으로 지원한다


## 1.5 요약

---

- 러스트는 바이너리를 만드는 시스템 프로그래밍 언어이다
- 유용한 에러 메시지가 포함된 엄격한 컴파일러가 함꼐 제공되므로 실수나 개선점을 쉽게 발견할 수 있다
- 러스트 관련 도구는 설치할 때 함께 제공되거나 공식적인 권장 사항이 있으므로 계속 새로운 도구를 찾고, 토론하고, 배우지 않아도 되어 시간을 절약할 수 있다
- 러스트는 Go, Node.js와는 달리 비동기 관련 런타임을 포함하지 않기 때문에 비동기 코드를 작성할 때 적합한 런타임을 선택해야 한다
- 웹 프레임워크는 런타임 위에 구축되므로 웹 프레임워크에 대한 선택은 나중에 선택할 런타임 프레임워크에 의해 결정된다
- 러스트의 속도, 안정성, 정확성은 소규모부터 대규모 웹 서비스 및 코드베이스까지 유지보수할 때 엄청난 도움이 될 것이다
- 문서와 테스트 언어 자체에 내장되어 있어 코드를 유지하고 관리하기가 훨씬 쉬워진다
